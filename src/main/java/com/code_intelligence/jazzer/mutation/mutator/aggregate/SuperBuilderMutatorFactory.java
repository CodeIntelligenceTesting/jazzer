/*
 * Copyright 2024 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.code_intelligence.jazzer.mutation.mutator.aggregate;

import static com.code_intelligence.jazzer.mutation.mutator.aggregate.AggregatesHelper.asInstantiationFunction;
import static com.code_intelligence.jazzer.mutation.mutator.aggregate.AggregatesHelper.parameterTypes;
import static com.code_intelligence.jazzer.mutation.mutator.aggregate.BeanSupport.*;
import static com.code_intelligence.jazzer.mutation.mutator.aggregate.BeanSupport.optionalClassForName;
import static com.code_intelligence.jazzer.mutation.support.TypeSupport.asSubclassOrEmpty;

import com.code_intelligence.jazzer.mutation.api.ExtendedMutatorFactory;
import com.code_intelligence.jazzer.mutation.api.MutatorFactory;
import com.code_intelligence.jazzer.mutation.api.SerializingMutator;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.AnnotatedType;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * {@code SuperBuilder} is a design pattern similar to the {@code Builder} pattern. Instead of
 * passing all parameters of a {@code Builder} into the constructor of the class to instantiate, the
 * whole {@code SuperBuilder} is passed on and the constructor extracts the values it needs from it.
 * <br>
 * This pattern is generated by Lombok's {@code @SuperBuilder} annotation.
 */
public final class SuperBuilderMutatorFactory implements MutatorFactory {

  @Override
  public Optional<SerializingMutator<?>> tryCreate(
      AnnotatedType type, ExtendedMutatorFactory factory) {
    return asSubclassOrEmpty(type, Object.class)
        .filter(this::isBuilderType)
        .flatMap(
            clazz -> {
              Method[] builderSetters = getBuilderSetters(clazz);
              return getBuilderMethod(clazz)
                  .map(
                      method ->
                          asInstantiationFunction(MethodHandles.lookup(), method, builderSetters))
                  .flatMap(
                      instantiator -> {
                        Function<Object[], Object> fromParametersToObject =
                            parameters -> {
                              Object instance = instantiator.apply(parameters);
                              factory.getCache().put(instance, parameters);
                              return instance;
                            };

                        Function<Object, Object[]> fromObjectToParameters =
                            instance -> factory.getCache().get(instance);

                        return AggregatesHelper.createMutator(
                            factory,
                            clazz,
                            parameterTypes(builderSetters),
                            fromParametersToObject,
                            fromObjectToParameters,
                            type,
                            false);
                      });
            });
  }

  private boolean isBuilderType(Class<?> clazz) {
    return clazz.getSimpleName().endsWith("Builder");
  }

  private Method[] getBuilderSetters(Class<?> clazz) {
    return findMethods(
            clazz,
            method ->
                method.getParameterCount() > 0 && method.getReturnType().isAssignableFrom(clazz))
        .toArray(Method[]::new);
  }

  private Optional<Method> getBuilderMethod(Class<?> builderClass) {
    // Lombok only generates a private constructor for super builder classes.
    // A new instance can be generated by a build method in the target class, though.
    String builderClassName = builderClass.getName();
    int indexInnerClassName = builderClassName.lastIndexOf("$");
    if (indexInnerClassName == -1) {
      return Optional.empty();
    }
    String targetClassName = builderClassName.substring(0, indexInnerClassName);
    return optionalClassForName(targetClassName)
        .flatMap(
            targetClass -> {
              List<Method> builderMethods =
                  findMethods(targetClass, method -> method.getReturnType().equals(builderClass))
                      .collect(Collectors.toList());
              // This factory only supports classes with exactly one builder method
              if (builderMethods.size() == 1) {
                return Optional.of(builderMethods.get(0));
              } else {
                return Optional.empty();
              }
            });
  }
}
